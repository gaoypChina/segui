// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.24.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'sequence.freezed.dart';

Future<String> showDnaUppercase({dynamic hint}) =>
    RustLib.instance.api.showDnaUppercase(hint: hint);

class AlignmentServices {
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;

  const AlignmentServices({
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
  });

  Future<void> concatAlignment(
          {required String outFname,
          required String outFmtStr,
          required String partitionFmt,
          dynamic hint}) =>
      RustLib.instance.api.alignmentServicesConcatAlignment(
        that: this,
        outFname: outFname,
        outFmtStr: outFmtStr,
        partitionFmt: partitionFmt,
      );

  static Future<AlignmentServices> newAlignmentServices({dynamic hint}) =>
      RustLib.instance.api.alignmentServicesNew(hint: hint);

  Future<void> summarizeAlignment(
          {required String outputPrefix,
          required int interval,
          dynamic hint}) =>
      RustLib.instance.api.alignmentServicesSummarizeAlignment(
        that: this,
        outputPrefix: outputPrefix,
        interval: interval,
      );

  @override
  int get hashCode =>
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AlignmentServices &&
          runtimeType == other.runtimeType &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir;
}

@freezed
sealed class FilteringParams with _$FilteringParams {
  const factory FilteringParams.minTax(
    double field0,
  ) = FilteringParams_MinTax;
  const factory FilteringParams.alnLen(
    int field0,
  ) = FilteringParams_AlnLen;
  const factory FilteringParams.parsInf(
    int field0,
  ) = FilteringParams_ParsInf;
  const factory FilteringParams.percInf(
    double field0,
  ) = FilteringParams_PercInf;
  const factory FilteringParams.taxonAll(
    List<String> field0,
  ) = FilteringParams_TaxonAll;
  const factory FilteringParams.none() = FilteringParams_None;
}

class FilteringServices {
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;
  final bool isConcat;
  final FilteringParams params;
  final String? outputFmt;
  final String? prefix;
  final String? partitionFmt;

  const FilteringServices({
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
    required this.isConcat,
    required this.params,
    this.outputFmt,
    this.prefix,
    this.partitionFmt,
  });

  Future<void> filter({dynamic hint}) =>
      RustLib.instance.api.filteringServicesFilter(
        that: this,
      );

  static Future<FilteringServices> newFilteringServices({dynamic hint}) =>
      RustLib.instance.api.filteringServicesNew(hint: hint);

  @override
  int get hashCode =>
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode ^
      isConcat.hashCode ^
      params.hashCode ^
      outputFmt.hashCode ^
      prefix.hashCode ^
      partitionFmt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FilteringServices &&
          runtimeType == other.runtimeType &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir &&
          isConcat == other.isConcat &&
          params == other.params &&
          outputFmt == other.outputFmt &&
          prefix == other.prefix &&
          partitionFmt == other.partitionFmt;
}

class IDExtractionServices {
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;
  final String? prefix;
  final bool isMap;

  const IDExtractionServices({
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
    this.prefix,
    required this.isMap,
  });

  Future<void> extractId({dynamic hint}) =>
      RustLib.instance.api.idExtractionServicesExtractId(
        that: this,
      );

  static Future<IDExtractionServices> newIDExtractionServices({dynamic hint}) =>
      RustLib.instance.api.idExtractionServicesNew(hint: hint);

  @override
  int get hashCode =>
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode ^
      prefix.hashCode ^
      isMap.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IDExtractionServices &&
          runtimeType == other.runtimeType &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir &&
          prefix == other.prefix &&
          isMap == other.isMap;
}

class PartitionServices {
  final List<String> inputFiles;
  final String inputPartFmt;
  final String output;
  final String outputPartFmt;
  final String datatype;
  final bool isUncheck;

  const PartitionServices({
    required this.inputFiles,
    required this.inputPartFmt,
    required this.output,
    required this.outputPartFmt,
    required this.datatype,
    required this.isUncheck,
  });

  Future<void> convertPartition({dynamic hint}) =>
      RustLib.instance.api.partitionServicesConvertPartition(
        that: this,
      );

  static Future<PartitionServices> newPartitionServices({dynamic hint}) =>
      RustLib.instance.api.partitionServicesNew(hint: hint);

  @override
  int get hashCode =>
      inputFiles.hashCode ^
      inputPartFmt.hashCode ^
      output.hashCode ^
      outputPartFmt.hashCode ^
      datatype.hashCode ^
      isUncheck.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PartitionServices &&
          runtimeType == other.runtimeType &&
          inputFiles == other.inputFiles &&
          inputPartFmt == other.inputPartFmt &&
          output == other.output &&
          outputPartFmt == other.outputPartFmt &&
          datatype == other.datatype &&
          isUncheck == other.isUncheck;
}

class SequenceConversionServices {
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;
  final String outputFmt;
  final bool sort;

  const SequenceConversionServices({
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
    required this.outputFmt,
    required this.sort,
  });

  Future<void> convertSequence({dynamic hint}) =>
      RustLib.instance.api.sequenceConversionServicesConvertSequence(
        that: this,
      );

  static Future<SequenceConversionServices> newSequenceConversionServices(
          {dynamic hint}) =>
      RustLib.instance.api.sequenceConversionServicesNew(hint: hint);

  @override
  int get hashCode =>
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode ^
      outputFmt.hashCode ^
      sort.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SequenceConversionServices &&
          runtimeType == other.runtimeType &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir &&
          outputFmt == other.outputFmt &&
          sort == other.sort;
}

class SequenceExtraction {
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;
  final String outputFmt;
  final SequenceExtractionParams params;

  const SequenceExtraction({
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
    required this.outputFmt,
    required this.params,
  });

  Future<void> extract({dynamic hint}) =>
      RustLib.instance.api.sequenceExtractionExtract(
        that: this,
      );

  static Future<SequenceExtraction> newSequenceExtraction({dynamic hint}) =>
      RustLib.instance.api.sequenceExtractionNew(hint: hint);

  @override
  int get hashCode =>
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode ^
      outputFmt.hashCode ^
      params.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SequenceExtraction &&
          runtimeType == other.runtimeType &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir &&
          outputFmt == other.outputFmt &&
          params == other.params;
}

@freezed
sealed class SequenceExtractionParams with _$SequenceExtractionParams {
  const factory SequenceExtractionParams.id(
    List<String> field0,
  ) = SequenceExtractionParams_Id;
  const factory SequenceExtractionParams.file(
    String field0,
  ) = SequenceExtractionParams_File;
  const factory SequenceExtractionParams.regex(
    String field0,
  ) = SequenceExtractionParams_Regex;
  const factory SequenceExtractionParams.none() = SequenceExtractionParams_None;
}

class SequenceRemoval {
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;
  final String outputFmt;
  final String? removeRegex;
  final List<String>? removeList;

  const SequenceRemoval({
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
    required this.outputFmt,
    this.removeRegex,
    this.removeList,
  });

  static Future<SequenceRemoval> newSequenceRemoval({dynamic hint}) =>
      RustLib.instance.api.sequenceRemovalNew(hint: hint);

  Future<void> removeSequence({dynamic hint}) =>
      RustLib.instance.api.sequenceRemovalRemoveSequence(
        that: this,
      );

  @override
  int get hashCode =>
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode ^
      outputFmt.hashCode ^
      removeRegex.hashCode ^
      removeList.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SequenceRemoval &&
          runtimeType == other.runtimeType &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir &&
          outputFmt == other.outputFmt &&
          removeRegex == other.removeRegex &&
          removeList == other.removeList;
}

class SequenceRenaming {
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;
  final String outputFmt;
  final SequenceRenamingParams params;

  const SequenceRenaming({
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
    required this.outputFmt,
    required this.params,
  });

  static Future<SequenceRenaming> newSequenceRenaming({dynamic hint}) =>
      RustLib.instance.api.sequenceRenamingNew(hint: hint);

  Future<void> renameSequence({dynamic hint}) =>
      RustLib.instance.api.sequenceRenamingRenameSequence(
        that: this,
      );

  @override
  int get hashCode =>
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode ^
      outputFmt.hashCode ^
      params.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SequenceRenaming &&
          runtimeType == other.runtimeType &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir &&
          outputFmt == other.outputFmt &&
          params == other.params;
}

@freezed
sealed class SequenceRenamingParams with _$SequenceRenamingParams {
  const factory SequenceRenamingParams.renameId(
    String field0,
  ) = SequenceRenamingParams_RenameId;
  const factory SequenceRenamingParams.removeStr(
    String field0,
  ) = SequenceRenamingParams_RemoveStr;
  const factory SequenceRenamingParams.removeRegex(
    String field0,
    bool field1,
  ) = SequenceRenamingParams_RemoveRegex;
  const factory SequenceRenamingParams.replaceStr(
    String field0,
    String field1,
  ) = SequenceRenamingParams_ReplaceStr;
  const factory SequenceRenamingParams.replaceRegex(
    String field0,
    String field1,
    bool field2,
  ) = SequenceRenamingParams_ReplaceRegex;
  const factory SequenceRenamingParams.none() = SequenceRenamingParams_None;
}

class SplitAlignmentServices {
  final String inputFile;
  final String inputFmt;
  final String datatype;
  final String? inputPartition;
  final String inputPartitionFmt;
  final String outputDir;
  final String? prefix;
  final String outputFmt;
  final bool isUncheck;

  const SplitAlignmentServices({
    required this.inputFile,
    required this.inputFmt,
    required this.datatype,
    this.inputPartition,
    required this.inputPartitionFmt,
    required this.outputDir,
    this.prefix,
    required this.outputFmt,
    required this.isUncheck,
  });

  static Future<SplitAlignmentServices> newSplitAlignmentServices(
          {dynamic hint}) =>
      RustLib.instance.api.splitAlignmentServicesNew(hint: hint);

  Future<void> splitAlignment({dynamic hint}) =>
      RustLib.instance.api.splitAlignmentServicesSplitAlignment(
        that: this,
      );

  @override
  int get hashCode =>
      inputFile.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      inputPartition.hashCode ^
      inputPartitionFmt.hashCode ^
      outputDir.hashCode ^
      prefix.hashCode ^
      outputFmt.hashCode ^
      isUncheck.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SplitAlignmentServices &&
          runtimeType == other.runtimeType &&
          inputFile == other.inputFile &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          inputPartition == other.inputPartition &&
          inputPartitionFmt == other.inputPartitionFmt &&
          outputDir == other.outputDir &&
          prefix == other.prefix &&
          outputFmt == other.outputFmt &&
          isUncheck == other.isUncheck;
}

class TranslationServices {
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;
  final String outputFmt;
  final String table;
  final int readingFrame;

  const TranslationServices({
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
    required this.outputFmt,
    required this.table,
    required this.readingFrame,
  });

  static Future<TranslationServices> newTranslationServices({dynamic hint}) =>
      RustLib.instance.api.translationServicesNew(hint: hint);

  Future<void> translateSequence({dynamic hint}) =>
      RustLib.instance.api.translationServicesTranslateSequence(
        that: this,
      );

  @override
  int get hashCode =>
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode ^
      outputFmt.hashCode ^
      table.hashCode ^
      readingFrame.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TranslationServices &&
          runtimeType == other.runtimeType &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir &&
          outputFmt == other.outputFmt &&
          table == other.table &&
          readingFrame == other.readingFrame;
}
