// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.14.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<String> showDnaUppercase({dynamic hint}) =>
    RustLib.instance.api.showDnaUppercase(hint: hint);

class AlignmentServices {
  final String? dir;
  final List<String> files;
  final String inputFmt;
  final String datatype;
  final String outputDir;

  const AlignmentServices({
    this.dir,
    required this.files,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
  });

  Future<void> concatAlignment(
          {required String outFname,
          required String outFmtStr,
          required String partitionFmt,
          dynamic hint}) =>
      RustLib.instance.api.alignmentServicesConcatAlignment(
        that: this,
        outFname: outFname,
        outFmtStr: outFmtStr,
        partitionFmt: partitionFmt,
      );

  static Future<AlignmentServices> newAlignmentServices({dynamic hint}) =>
      RustLib.instance.api.alignmentServicesNew(hint: hint);

  Future<void> summarizeAlignment(
          {required String outputPrefix,
          required int interval,
          dynamic hint}) =>
      RustLib.instance.api.alignmentServicesSummarizeAlignment(
        that: this,
        outputPrefix: outputPrefix,
        interval: interval,
      );

  @override
  int get hashCode =>
      dir.hashCode ^
      files.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AlignmentServices &&
          runtimeType == other.runtimeType &&
          dir == other.dir &&
          files == other.files &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir;
}

class FilteringServices {
  final String? dir;
  final List<String> files;
  final String inputFmt;
  final String datatype;
  final String outputDir;
  final bool isConcat;

  const FilteringServices({
    this.dir,
    required this.files,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
    required this.isConcat,
  });

  Future<void> filterMinimalLength({required int length, dynamic hint}) =>
      RustLib.instance.api.filteringServicesFilterMinimalLength(
        that: this,
        length: length,
      );

  Future<void> filterMinimalTaxa(
          {required double percent, int? taxonCount, dynamic hint}) =>
      RustLib.instance.api.filteringServicesFilterMinimalTaxa(
        that: this,
        percent: percent,
        taxonCount: taxonCount,
      );

  Future<void> filterParsimonyInfCount({required int count, dynamic hint}) =>
      RustLib.instance.api.filteringServicesFilterParsimonyInfCount(
        that: this,
        count: count,
      );

  Future<void> filterPercentInformative(
          {required double percent, dynamic hint}) =>
      RustLib.instance.api.filteringServicesFilterPercentInformative(
        that: this,
        percent: percent,
      );

  static Future<FilteringServices> newFilteringServices({dynamic hint}) =>
      RustLib.instance.api.filteringServicesNew(hint: hint);

  @override
  int get hashCode =>
      dir.hashCode ^
      files.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode ^
      isConcat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FilteringServices &&
          runtimeType == other.runtimeType &&
          dir == other.dir &&
          files == other.files &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir &&
          isConcat == other.isConcat;
}

class PartitionServices {
  final List<String> fileInputs;
  final String inputPartFmt;
  final String output;
  final String outputPartFmt;
  final String datatype;
  final bool isUncheck;

  const PartitionServices({
    required this.fileInputs,
    required this.inputPartFmt,
    required this.output,
    required this.outputPartFmt,
    required this.datatype,
    required this.isUncheck,
  });

  Future<void> convertPartition({dynamic hint}) =>
      RustLib.instance.api.partitionServicesConvertPartition(
        that: this,
      );

  static Future<PartitionServices> newPartitionServices({dynamic hint}) =>
      RustLib.instance.api.partitionServicesNew(hint: hint);

  @override
  int get hashCode =>
      fileInputs.hashCode ^
      inputPartFmt.hashCode ^
      output.hashCode ^
      outputPartFmt.hashCode ^
      datatype.hashCode ^
      isUncheck.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PartitionServices &&
          runtimeType == other.runtimeType &&
          fileInputs == other.fileInputs &&
          inputPartFmt == other.inputPartFmt &&
          output == other.output &&
          outputPartFmt == other.outputPartFmt &&
          datatype == other.datatype &&
          isUncheck == other.isUncheck;
}

class SequenceServices {
  final String? dir;
  final List<String> files;
  final String inputFmt;
  final String datatype;
  final String outputDir;

  const SequenceServices({
    this.dir,
    required this.files,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
  });

  Future<void> convertSequence(
          {required String outputFmt, required bool sort, dynamic hint}) =>
      RustLib.instance.api.sequenceServicesConvertSequence(
        that: this,
        outputFmt: outputFmt,
        sort: sort,
      );

  static Future<SequenceServices> newSequenceServices({dynamic hint}) =>
      RustLib.instance.api.sequenceServicesNew(hint: hint);

  Future<void> parseSequenceId({required bool isMap, dynamic hint}) =>
      RustLib.instance.api.sequenceServicesParseSequenceId(
        that: this,
        isMap: isMap,
      );

  Future<void> translateSequence(
          {required String table,
          required int readingFrame,
          required String outputFmt,
          dynamic hint}) =>
      RustLib.instance.api.sequenceServicesTranslateSequence(
        that: this,
        table: table,
        readingFrame: readingFrame,
        outputFmt: outputFmt,
      );

  @override
  int get hashCode =>
      dir.hashCode ^
      files.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SequenceServices &&
          runtimeType == other.runtimeType &&
          dir == other.dir &&
          files == other.files &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir;
}
