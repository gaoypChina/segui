// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.14.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

Future<String> showDnaUppercase({dynamic hint}) =>
    RustLib.instance.api.showDnaUppercase(hint: hint);

class AlignmentServices {
  final String? dir;
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;

  const AlignmentServices({
    this.dir,
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
  });

  Future<void> concatAlignment(
          {required String outFname,
          required String outFmtStr,
          required String partitionFmt,
          dynamic hint}) =>
      RustLib.instance.api.alignmentServicesConcatAlignment(
        that: this,
        outFname: outFname,
        outFmtStr: outFmtStr,
        partitionFmt: partitionFmt,
      );

  static Future<AlignmentServices> newAlignmentServices({dynamic hint}) =>
      RustLib.instance.api.alignmentServicesNew(hint: hint);

  Future<void> summarizeAlignment(
          {required String outputPrefix,
          required int interval,
          dynamic hint}) =>
      RustLib.instance.api.alignmentServicesSummarizeAlignment(
        that: this,
        outputPrefix: outputPrefix,
        interval: interval,
      );

  @override
  int get hashCode =>
      dir.hashCode ^
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AlignmentServices &&
          runtimeType == other.runtimeType &&
          dir == other.dir &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir;
}

class FilteringServices {
  final String? dir;
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;
  final bool isConcat;

  const FilteringServices({
    this.dir,
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
    required this.isConcat,
  });

  Future<void> filterMinimalLength({required int length, dynamic hint}) =>
      RustLib.instance.api.filteringServicesFilterMinimalLength(
        that: this,
        length: length,
      );

  Future<void> filterMinimalTaxa(
          {required double percent, int? taxonCount, dynamic hint}) =>
      RustLib.instance.api.filteringServicesFilterMinimalTaxa(
        that: this,
        percent: percent,
        taxonCount: taxonCount,
      );

  Future<void> filterParsimonyInfCount({required int count, dynamic hint}) =>
      RustLib.instance.api.filteringServicesFilterParsimonyInfCount(
        that: this,
        count: count,
      );

  Future<void> filterPercentInformative(
          {required double percent, dynamic hint}) =>
      RustLib.instance.api.filteringServicesFilterPercentInformative(
        that: this,
        percent: percent,
      );

  static Future<FilteringServices> newFilteringServices({dynamic hint}) =>
      RustLib.instance.api.filteringServicesNew(hint: hint);

  @override
  int get hashCode =>
      dir.hashCode ^
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode ^
      isConcat.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FilteringServices &&
          runtimeType == other.runtimeType &&
          dir == other.dir &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir &&
          isConcat == other.isConcat;
}

class PartitionServices {
  final List<String> inputFiles;
  final String inputPartFmt;
  final String output;
  final String outputPartFmt;
  final String datatype;
  final bool isUncheck;

  const PartitionServices({
    required this.inputFiles,
    required this.inputPartFmt,
    required this.output,
    required this.outputPartFmt,
    required this.datatype,
    required this.isUncheck,
  });

  Future<void> convertPartition({dynamic hint}) =>
      RustLib.instance.api.partitionServicesConvertPartition(
        that: this,
      );

  static Future<PartitionServices> newPartitionServices({dynamic hint}) =>
      RustLib.instance.api.partitionServicesNew(hint: hint);

  @override
  int get hashCode =>
      inputFiles.hashCode ^
      inputPartFmt.hashCode ^
      output.hashCode ^
      outputPartFmt.hashCode ^
      datatype.hashCode ^
      isUncheck.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PartitionServices &&
          runtimeType == other.runtimeType &&
          inputFiles == other.inputFiles &&
          inputPartFmt == other.inputPartFmt &&
          output == other.output &&
          outputPartFmt == other.outputPartFmt &&
          datatype == other.datatype &&
          isUncheck == other.isUncheck;
}

class SequenceRemoval {
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;
  final String outputFmt;
  final String? removeRegex;
  final List<String>? removeList;

  const SequenceRemoval({
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
    required this.outputFmt,
    this.removeRegex,
    this.removeList,
  });

  static Future<SequenceRemoval> newSequenceRemoval({dynamic hint}) =>
      RustLib.instance.api.sequenceRemovalNew(hint: hint);

  Future<void> removeSequence({dynamic hint}) =>
      RustLib.instance.api.sequenceRemovalRemoveSequence(
        that: this,
      );

  @override
  int get hashCode =>
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode ^
      outputFmt.hashCode ^
      removeRegex.hashCode ^
      removeList.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SequenceRemoval &&
          runtimeType == other.runtimeType &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir &&
          outputFmt == other.outputFmt &&
          removeRegex == other.removeRegex &&
          removeList == other.removeList;
}

class SequenceServices {
  final String? dir;
  final List<String> inputFiles;
  final String inputFmt;
  final String datatype;
  final String outputDir;

  const SequenceServices({
    this.dir,
    required this.inputFiles,
    required this.inputFmt,
    required this.datatype,
    required this.outputDir,
  });

  Future<void> convertSequence(
          {required String outputFmt, required bool sort, dynamic hint}) =>
      RustLib.instance.api.sequenceServicesConvertSequence(
        that: this,
        outputFmt: outputFmt,
        sort: sort,
      );

  static Future<SequenceServices> newSequenceServices({dynamic hint}) =>
      RustLib.instance.api.sequenceServicesNew(hint: hint);

  Future<void> parseSequenceId(
          {required String outputFname, required bool isMap, dynamic hint}) =>
      RustLib.instance.api.sequenceServicesParseSequenceId(
        that: this,
        outputFname: outputFname,
        isMap: isMap,
      );

  Future<void> translateSequence(
          {required String table,
          required int readingFrame,
          required String outputFmt,
          dynamic hint}) =>
      RustLib.instance.api.sequenceServicesTranslateSequence(
        that: this,
        table: table,
        readingFrame: readingFrame,
        outputFmt: outputFmt,
      );

  @override
  int get hashCode =>
      dir.hashCode ^
      inputFiles.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      outputDir.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SequenceServices &&
          runtimeType == other.runtimeType &&
          dir == other.dir &&
          inputFiles == other.inputFiles &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          outputDir == other.outputDir;
}

class SplitAlignmentServices {
  final String? dir;
  final String inputFile;
  final String inputFmt;
  final String datatype;
  final String? inputPartition;
  final String inputPartitionFmt;
  final String outputDir;
  final String? prefix;
  final String outputFmt;
  final bool isUncheck;

  const SplitAlignmentServices({
    this.dir,
    required this.inputFile,
    required this.inputFmt,
    required this.datatype,
    this.inputPartition,
    required this.inputPartitionFmt,
    required this.outputDir,
    this.prefix,
    required this.outputFmt,
    required this.isUncheck,
  });

  static Future<SplitAlignmentServices> newSplitAlignmentServices(
          {dynamic hint}) =>
      RustLib.instance.api.splitAlignmentServicesNew(hint: hint);

  Future<void> splitAlignment({dynamic hint}) =>
      RustLib.instance.api.splitAlignmentServicesSplitAlignment(
        that: this,
      );

  @override
  int get hashCode =>
      dir.hashCode ^
      inputFile.hashCode ^
      inputFmt.hashCode ^
      datatype.hashCode ^
      inputPartition.hashCode ^
      inputPartitionFmt.hashCode ^
      outputDir.hashCode ^
      prefix.hashCode ^
      outputFmt.hashCode ^
      isUncheck.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SplitAlignmentServices &&
          runtimeType == other.runtimeType &&
          dir == other.dir &&
          inputFile == other.inputFile &&
          inputFmt == other.inputFmt &&
          datatype == other.datatype &&
          inputPartition == other.inputPartition &&
          inputPartitionFmt == other.inputPartitionFmt &&
          outputDir == other.outputDir &&
          prefix == other.prefix &&
          outputFmt == other.outputFmt &&
          isUncheck == other.isUncheck;
}
