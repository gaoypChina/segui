// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.34.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

enum CsvSegulType {
  /// Locus summary from alignment summary
  locusSummary,

  /// Taxon summary from alignment summary
  taxonSummary,

  /// Whole read summary from raw read summary
  /// Add default settings
  wholeReadSummary,

  /// Per read summary from raw read summary
  /// When the complete setting is used.
  perReadSummary,

  /// Contig summary from assembly summary
  contigSummary,
  ;
}

class CsvSummaryServices {
  final String inputPath;
  final CsvSegulType segulType;

  const CsvSummaryServices({
    required this.inputPath,
    required this.segulType,
  });

  Future<List<String>> getColumnNames({dynamic hint}) => RustLib.instance.api
      .crateApiCsvCsvSummaryServicesGetColumnNames(that: this, hint: hint);

  Future<int> getLine({dynamic hint}) => RustLib.instance.api
      .crateApiCsvCsvSummaryServicesGetLine(that: this, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<CsvSummaryServices> newInstance(
          {required String inputPath,
          required CsvSegulType segulType,
          dynamic hint}) =>
      RustLib.instance.api.crateApiCsvCsvSummaryServicesNew(
          inputPath: inputPath, segulType: segulType, hint: hint);

  Future<Map<String, String>> parseColumns(
          {required String colName, dynamic hint}) =>
      RustLib.instance.api.crateApiCsvCsvSummaryServicesParseColumns(
          that: this, colName: colName, hint: hint);

  @override
  int get hashCode => inputPath.hashCode ^ segulType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CsvSummaryServices &&
          runtimeType == other.runtimeType &&
          inputPath == other.inputPath &&
          segulType == other.segulType;
}
